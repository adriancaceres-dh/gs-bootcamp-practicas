-------------------------------------------------------¡¡¡TEST UNITARIOS SIN MOCKS!!!-------------------------------------------------------

1- Agregamos dependencias

2-En test/java/com.glubits.employees crear las siguientes carpetas:
    integration
    unit
    utils

3- La carpeta unit contendra las carpetas:
    repository
    service

4- La carpeta utils contendra:
    DTOSFACTORYS
    FACTORYS

5-Ir a classRepository.java hacer : alt insert/test para que genere los test de los metodos (colocarlo en la carpeta unit/repository)
  Instanciar la clase que voy a usar ejemplo: DepartmentRepository departmentRepository = new DepartmentRepository(); (no va el autowired porque no hay contexto de spring)
  EJEMPLOS:

class EmployeeRepositoryTest {

    EmployeeRepository employeeRepository;

     @Test
    void save(){
        // arrange
        Department entity = ;
        Integer expected = ;

        // act
        var result = departmentRepository.save(entity);

        // assert
        Assertions.assertEquals(expected,result);
    }

@Test
    void save(){
        // arrange
        Department entity = DepartmentFactory.getDepartament();
        Integer expected = 3;// debe coincidir con la cantidad de datos iniciales más 1

        // act
        var result = departmentRepository.save(entity);

        // assert
        Assertions.assertEquals(expected,result);
    }


  @Test
    void delete() {
        // arrange
        Integer id = 2;
        Integer expected = 2;

        // act
        var result = departmentRepository.delete(id);

        // assert
        Assertions.assertEquals(expected, result);
    }

    @Test
    void deleteWithNotExistentId() {
        // arrange
        Integer id = 2;

        // act & assert
        Assertions.assertThrows(NotFoundException.class,
                () -> departmentRepository.delete(id));
    }


  @Test
    void findById() {
        // arrange
        Integer id = 1;
        Optional<Employee> expected = Optional.of(EmployeeFactory.getMarco());

        // act
        var result = employeeRepository.findById(id);

        // assert
        Assertions.assertEquals(expected, result);
    }


    @Test
    void findByIdNotExistent() {
        // arrange
        Integer id = 3;
        Optional<Employee> expected = Optional.empty();

        // act
        var result = employeeRepository.findById(id);

        // assert
        Assertions.assertEquals(expected, result);
    }


  @Test
    void findByName() {
        // arrange
        String name = "Gabi";
        List<Employee> expected = List.of(EmployeeFactory.getGabi());

        // act
        var result = employeeRepository.findByName(name);

        // assert
        Assertions.assertEquals(expected, result);
    }

   @Test
    void findByNameNotExistent() {
        // arrange
        String name = "Mati";
        List<Employee> expected =List.of();

        // act
        var result = employeeRepository.findByName(name);

        // assert
        Assertions.assertEquals(expected, result);
    }


    @Test
    void listAll() {
        // arrange
        List<Employee> expected = List.of(//los que estan agregados en el json y deben estar en el orden del json
                EmployeeFactory.getGabi(),
                EmployeeFactory.getMarco(),
                EmployeeFactory.getJean());
        // act
        var result = employeeRepository.listAll();

        // assert
        Assertions.assertEquals(expected, result);
    }
}


6- Setear entidad para eso crear json: En test/directory/resources/(ej: department.json):

[
  {
    "id": 0,
    "name": "Gabi",
    "age": 19,
    "email": "gabimonzon@digitalhouse.com",
    "address": "Av. Siempreviva 742"
  },
  {
    "id": 1,
    "name": "Marco",
    "age": 24,
    "email": "marcoavila@digitalhouse.com",
    "address": "221B Baker Street"
  },
  {
    "id": 2,
    "name": "Jean",
    "age": 25,
    "email": "jeancardo@digitalhouse.com",
    "address": "Andén 9 y 3/4"
  }
]



7-Ir a la carpeta utils y cread Factory :
   
 public class EmployeeFactory {

    public static Employee getTincho(){
        return Employee.builder()
                .name("Tincho")
                .age(30)
                .address("Av. BuenaVista 222")
                .email("martinmarquez@digitalhouse.com")
                .build();
    }

    public static Employee getMarco(){
        return Employee.builder()
                .id(1)
                .name("Marco")
                .age(24)
                .email("marcoavila@digitalhouse.com")
                .address("221B Baker Street")
                .build();
    }

    public static Employee getGabi(){
        return Employee.builder()
                .id(0)
                .name("Gabi")
                .age(19)
                .email("gabimonzon@digitalhouse.com")
                .address("Av. Siempreviva 742")
                .build();
    }

    public static Employee getJean(){
        return Employee.builder()
                .id(2)
                .name("Jean")
                .age(25)
                .email("jeancardo@digitalhouse.com")
                .address("Andén 9 y 3/4")
                .build();
    }
}









-------------------------------------------------------¡¡¡TEST UNITARIOS CON MOCKS!!!-------------------------------------------------------

1- La carpeta unit contendra las carpetas:
Dentro de service vamos a crear la clases de los servicio que corresponden:alt insert/test para que genere los test de los metodos (colocarlo en la carpeta unit/service)
  
  EJEMPLOS:

@ExtendWith(MockitoExtension.class) //SIEMPRE SE PONE
class EmployeeServiceTest {

    @Mock
    EmployeeRepository employeeRepository; //dependencia instanciada

    @InjectMocks
    EmployeeService employeeService; // a quien le inyectamos los test con mocks

 @Test
    void saveEmployee() {
          // arrange
        EmployeeDTO employeeDTO = EmployeeDTOFactory.getTinchoDTO(); //LO ESPERADO
        CrudDTO expected = CrudDTOFactory.crudDTOCreationWithId1(); //LLAMAMOS AL CRUD QUE CREAMOS
        Employee entity = EmployeeFactory.getTincho(); //MANDAR LO DE LA FACTORY, EN ESTE CASO LA ENTITY ES LO QUE DEBERIAMOS MANDAR AL SERVICIO EN LA CONVERSION
          
         // act
            // whens
        Mockito.when(employeeRepository.save(entity)).thenReturn(0); //CUANDO SE EJECUTE ESTO DEVOLVEME ESTE VALOR
        var result = employeeService.saveEmployee(employeeDTO);

          // assert
        Assertions.assertEquals(expected, result);
    }

    @Test
    void deleteEmployee() {
        // arrange
        Integer id = 1; // necesita un entero
        CrudDTO expected = CrudDTOFactory.crudDTODeletationWithId1(); // se debe crear el factory. lo que  espera es.
        
        // act con mocks
        var result = employeeService.deleteEmployee(id); //Llamo al metodo y le paso el id que le corresponde
        Mockito.when(employeeRepository.delete(1)).thenReturn(1);// mockeo la llamada al repository(puede haber varios when), luego de esto que retorne el valor que corresponde.
        // debe llegar el valor que le corresponde al metodo.

        // assert
        Assertions.assertEquals(expected, result);
    }

    @Test
    void listAllEmployees() { // los empleados los pasos a un factoryDto porque en el metodo los pasa a una lista dto.
        // arrange
        List<EmployeeDTO> expected = List.of(EmployeeDTOFactory.getGabiDTO(),//Lista de los empleados e la factory, por orden que fueron creados.
                EmployeeDTOFactory.getMarcoDTO(),
                EmployeeDTOFactory.getJeanDTO());

        List<Employee> shouldReturn = List.of(EmployeeFactory.getGabi(),//Lista de la entidad.La factory comun
                EmployeeFactory.getMarco(),
                EmployeeFactory.getJean());

        // act
         var result = employeeService.listAllEmployees();//Llamada 
        Mockito.when(employeeRepository.listAll()).thenReturn(shouldReturn);// Llamada al repository en el metodo no tiene parametro por eso es listAll(). siempre que
//que se llame a esto retorname la lista de la entidad
       

        // assert
        Assertions.assertEquals(expected, result);
    }

    @Test
    void findOneEmployee() {
        // arrange
        Integer id = 1;//Buscamos el empleado 1
        EmployeeDTO expected = EmployeeDTOFactory.getMarcoDTO();//Lo que devuelve , se espera.
        Employee marco = EmployeeFactory.getMarco();//Devolver una entidad en este caso 

        // act
        var result = employeeService.findOneEmployee(id);
        Mockito.when(employeeRepository.findById(id)).thenReturn(Optional.of(marco));
                                                     // aca devuelve a marco. esta en un optional porque findById devuelve un optional. se puede ver en employeerepository
        // assert
        Assertions.assertEquals(expected, result);
    }

    @Test
    void findOneEmployeeWithNotExistentId() {
        // arrange
        Integer id = 999999;// id que no existe

        // mockeos

        Mockito.when(employeeRepository.findById(id)).thenReturn(Optional.empty()); // es empty porque esta vacio, no existe.

        // act & assert
        Assertions.assertThrows(   // Este seria nuestro expected, es una excepcion
                NotFoundException.class, // ver la excepcion que da el servicio
                () -> employeeService.findOneEmployee(id) // el ejecutable 
        );
    }

    @Test
    void findByName() {
        // arrange
        String name = "Jean"; //como parametro
        List<EmployeeDTO> expected = List.of(EmployeeDTOFactory.getJeanDTO());// lo esperado , en la lista lo que tiene que encontrar en este caso es un empleado 
        Employee jean = EmployeeFactory.getJean(); // Entidad 

        // act
        Mockito.when(employeeRepository.findByName(name)).thenReturn(List.of(jean));// retorno una entidad
        var result = employeeService.findByName(name); 

        // assert
        Assertions.assertEquals(expected, result);
    }

    @Test
    void findByNameNotFound() {
        // arrange
        String name = "Amarancio"; // El parametro que busca
        List<EmployeeDTO> expected = List.of(); // Lo esperado una lista vacia en este caso.Porque no tiene una excepcion el EmployeeService

        // act
        Mockito.when(employeeRepository.findByName(name)).thenReturn(List.of());//Retorna una lista vacia
        var result = employeeService.findByName(name);

        // assert
        Assertions.assertEquals(expected, result);
    }
}


2- En la carpeta utils crear la clase CrudDTOFactory: es un mensaje y una accion.
EJEMPLOS:

public class CrudDTOFactory {

    public static CrudDTO crudDTOCreationWithId1(){
        return CrudDTO.builder()
                .message("Se creo el empleado con id: " + 0)
                .action(CrudEnum.CREATION)
                .build();
    }

    public static CrudDTO crudDTODeletationWithId1(){
        return CrudDTO.builder()
                .message("Se elimino el empleado con id " + 1)
                .action(CrudEnum.DELETATION)
                .build();
    }

    public static CrudDTO crudDTOCreationWithId2(){
        return CrudDTO.builder()
                .message("Se creo el departamento con id: " + 2)
                .action(CrudEnum.CREATION)
                .build();
    }

    public static CrudDTO crudDTODeletationWithId2(){
        return CrudDTO.builder()
                .message("Se elimino el departamento con id " + 2)
                .action(CrudEnum.DELETATION)
                .build();
    }

    public static CrudDTO crudDTOCreationWithId3(){
        return CrudDTO.builder()
                .message("Se creo el empleado con id: " + 3)
                .action(CrudEnum.CREATION)
                .build();
    }

    public static CrudDTO crudDTOReadingNotFoundWithId7(){
        return CrudDTO.builder()
                .message("No se pudo encontrar el empleado con id " + 7)
                .action(CrudEnum.READING)
                .build();
    }
}

3- Ir a la carpeta utils y cread Factory :
EJEMPLO:

public class EmployeeDTOFactory {

    public static EmployeeDTO getTinchoDTO(){ //SIN ID PORQUE NOS LO DEVUELVE EL METODO saveEmployee
        return EmployeeDTO.builder()
                .name("Tincho")
                .age(30)
                .address("Av. BuenaVista 222")
                .email("martinmarquez@digitalhouse.com")
                .build();
    }

    public static EmployeeDTO getMarcoDTO(){

        return EmployeeDTO.builder()
                .id(1)
                .name("Marco")
                .age(24)
                .email("marcoavila@digitalhouse.com")
                .address("221B Baker Street")
                .build();
    }

    public static EmployeeDTO getGabiDTO(){

        return EmployeeDTO.builder()
                .id(0)
                .name("Gabi")
                .age(19)
                .email("gabimonzon@digitalhouse.com")
                .address("Av. Siempreviva 742")
                .build();
    }

    public static EmployeeDTO getJeanDTO(){
        return EmployeeDTO.builder()
                .id(2)
                .name("Jean")
                .age(25)
                .email("jeancardo@digitalhouse.com")
                .address("Andén 9 y 3/4")
                .build();
    }

}





-------------------------------------------------------¡¡¡TEST DE INTEGRACION!!!-------------------------------------------------------
//TESTEAR EL CONTROLADOR EN ESTE CASO DE EMPLOYEE//
 
1- crear Carpeta integration. Dentro de el creamos una class en este caso EmployeeControllerIntegrationTest.

@SpringBootTest //Anotacion levanta el contexto de la aplicacion.
                // Al contenedor de spring y a las aplicaciones le llamamos contexto . Aca queremos todo el contexto.
@AutoConfigureMockMvc //Levanta a las config, autoconfigure 

public class EmployeeControllerIntegrationTest {

  @Autowired
    MockMvc mockMvc; // Es como la persona que manda el request.Clase que permite ejecutar las consultas a un endpoint en particular

    ObjectWriter writer; // inicializar un objeto 


  @BeforeEach

    public void setupBeforeAll(){
        writer = new ObjectMapper()//Permite traducir un objeto nuestro a un string plano en JSON.
                .registerModule(new JavaTimeModule())
                .writer();
    }
   
2) Realizamos los test:

   @Test
    public void saveEmployee() throws Exception {

        // Arrange
        
        EmployeeDTO newEmployee = EmployeeDTOFactory.getTinchoDTO(); // Param necesario
       
        CrudDTO expected = CrudDTOFactory.crudDTOCreationWithId3(); // La devolucion, Lo que espero, seria el BodyExcepted



        //REQUEST CON MockHttpServletRequestBuilder & MockMvcRequestBuilders (librerias)
        
        MockHttpServletRequestBuilder request = MockMvcRequestBuilders  //Declaramos la request que vamos a llamar o hacer
                .post("/employee/save") // POST porque hacemos un save nos fijamos en el controller
                .contentType(MediaType.APPLICATION_JSON) // aca aviso que estoy enviando un JSON
                .content(writer.writeValueAsString(newEmployee)); // y aca hay que usar el writter . Es el empleado convertido en json

        
        //Los 3 EXPECTED con ResultMatcher & MockMvcResultMatchers
       
        ResultMatcher statusExpected = MockMvcResultMatchers.status().isOk(); //StatusExpected el isOk puede varias badrequest ejemplo.

             
        ResultMatcher bodyExpected = MockMvcResultMatchers.content().json( //BodyExpected
                writer.writeValueAsString(expected)
        );

           
        ResultMatcher contentTypeExpected = MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON); //ContentTypeExpected



        // act & assert con mockmvc
        mockMvc.perform(request)// le paso la request
                .andDo(MockMvcResultHandlers.print()) //Devuelve el request de manera gráfica
                .andExpect(statusExpected)
                .andExpect(bodyExpected)
                .andExpect(contentTypeExpected);
    }


  
@Test
    public void findOneEmployee() throws Exception {
        // arrange
        Integer id = EmployeeDTOFactory.getJeanDTO().getId();//PARAM REQUERIDO
        EmployeeDTO expected = EmployeeDTOFactory.getJeanDTO();// ESPERO UN EMPLOYEEDTO

           //REQUEST CON MockHttpServletRequestBuilder & MockMvcRequestBuilders (librerias)
              //Declaramos la request que vamos a llamar o hacer
        MockHttpServletRequestBuilder request = MockMvcRequestBuilders.get("/employee/get/"+id);


        //Los 3 EXPECTED con ResultMatcher & MockMvcResultMatchers
             //StatusExpected
        ResultMatcher statusExpected = MockMvcResultMatchers.status().isOk();

             //BodyExpected
        ResultMatcher bodyExpected = MockMvcResultMatchers.content().json(
                writer.writeValueAsString(expected)
        );

              //ContentTypeExpected
        ResultMatcher contentTypeExpected = MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON);


        // act & assert con mockmvc
        mockMvc.perform(request)
                .andDo(MockMvcResultHandlers.print()) //Devuelve el request de manera gráfica
                .andExpect(statusExpected)
                .andExpect(bodyExpected)
                .andExpect(contentTypeExpected);
    }


 @Test
    public void deleteEmploee() throws Exception {
        //arrange
        
        Integer id = 1;
        CrudDTO expected = CrudDTOFactory.crudDTODeletationWithId1();

        //REQUEST CON MockHttpServletRequestBuilder & MockMvcRequestBuilders (librerias)
           //Declaramos la request que vamos a llamar o hacer
        MockHttpServletRequestBuilder request = MockMvcRequestBuilders.delete("/employee/delete/{id}",id);

        //Los 3 EXPECTED con ResultMatcher & MockMvcResultMatchers
            //StatusExpected
        ResultMatcher statusExpected = MockMvcResultMatchers.status().isOk();

            //BodyExpected
        ResultMatcher bodyExpected = MockMvcResultMatchers.content().json(
                writer.writeValueAsString(expected)
        );

           //ContentTypeExpected
        ResultMatcher contentTypeExpected = MockMvcResultMatchers.content().contentType(MediaType.APPLICATION_JSON);

        // act & assert con mockmvc
        mockMvc.perform(request)
                .andDo(MockMvcResultHandlers.print()) //Devuelve el request de manera gráfica
                .andExpect(statusExpected)
                .andExpect(bodyExpected)
                .andExpect(contentTypeExpected);
    }
}


3) EN CrudDTOFactory:

 public static CrudDTO crudDTOCreationWithId1(){
        return CrudDTO.builder()
                .message("Se creo el empleado con id: " + 0)
                .action(CrudEnum.CREATION)
                .build();
    }

    public static CrudDTO crudDTODeletationWithId1(){
        return CrudDTO.builder()
                .message("Se elimino el empleado con id " + 1)
                .action(CrudEnum.DELETATION)
                .build();
    }

    public static CrudDTO crudDTOCreationWithId2(){
        return CrudDTO.builder()
                .message("Se creo el departamento con id: " + 2)
                .action(CrudEnum.CREATION)
                .build();
    }

    public static CrudDTO crudDTODeletationWithId2(){
        return CrudDTO.builder()
                .message("Se elimino el departamento con id " + 2)
                .action(CrudEnum.DELETATION)
                .build();
    }

    public static CrudDTO crudDTOReadingNotFoundWithId7(){
        return CrudDTO.builder()
                .message("No se pudo encontrar el empleado con id " + 7)
                .action(CrudEnum.READING)
                .build();
    }
}

